@startuml Additive Synthesis - Flux Signal par Oscillateur
!theme plain
skinparam backgroundColor #FEFEFE
skinparam defaultFontName Arial
skinparam defaultFontSize 11

title Sp3ctra - Synthèse Additive\n(Traitement Signal Détaillé par Oscillateur)

' Define colors
!define INPUT_COLOR #E3F2FD
!define PROCESS_COLOR #FFE0B2
!define OUTPUT_COLOR #C8E6C9
!define STEREO_COLOR #F8BBD0

start

:Début Worker Thread;
note right
  **Context:**
  Worker traite son range de notes
  Ex: Worker 0 → Notes 0-23
  Buffers locaux pré-alloués
end note

partition "Initialisation Buffers" {
  :Reset buffers locaux à zéro;
  note right
    - thread_additiveBuffer[64] = 0
    - thread_stereoBuffer_L[64] = 0
    - thread_stereoBuffer_R[64] = 0
    - thread_sumVolumeBuffer[64] = 0
    - thread_maxVolumeBuffer[64] = 0
  end note
}

partition "Preprocessing Image" #INPUT_COLOR {
  :Pour chaque note dans range;
  
  :Moyennage pixels → note;
  note right
    **Exemple:** pixels_per_note = 36
    sum = 0
    for (p = 0; p < 36; p++)
      sum += imageData[note*36 + p]
    imageBuffer[note] = sum / 36
  end note
  
  if (invert_intensity?) then (oui)
    :imageBuffer = 1.0 - imageBuffer;
  endif
  
  if (enable_gamma?) then (oui)
    :imageBuffer = pow(imageBuffer, gamma);
    note right
      **Gamma mapping:**
      Ajuste réponse perceptuelle
      gamma < 1: expand dynamics
      gamma > 1: compress dynamics
    end note
  endif
}

:Boucle sur chaque oscillateur\ndans worker range;

repeat

  partition "1. GÉNÉRATION FORME D'ONDE" #PROCESS_COLOR {
    :Lecture échantillons pré-calculés;
    note right
      **Pour 64 samples:**
      for (s = 0; s < 64; s++)
        waveBuffer[s] = 
          precomputed_wave_data[note][s]
          / WAVE_AMP_RESOLUTION
      
      **Normalisation:** [-1.0, +1.0]
      WAVE_AMP_RESOLUTION = 65536
    end note
    
    :waveBuffer[64] samples\nSinus normalisé [-1, +1]|
  }
  
  partition "2. ENVELOPPE GAP_LIMITER" #PROCESS_COLOR {
    :Récupération volume cible;
    note right
      target_volume = imageBuffer[note]
      current_volume = waves[note].current_volume
    end note
    
    if (target > current?) then (Attack)
      if (INSTANT_ATTACK?) then (oui)
        :volumeBuffer = target\n(instantané);
        note right
          **Attack instantané:**
          Supprime "poussière" audio
          Pas de rampe progressive
        end note
      else (non)
        :Rampe progressive attack;
        note right
          alpha = waves[note].alpha_up
          for (s = 0; s < 64; s++)
            v += alpha * (target - v)
            volumeBuffer[s] = v
        end note
      endif
    else (Release)
      :Rampe progressive release;
      note right
        **Release pondéré par fréquence:**
        alpha = waves[note].alpha_down_weighted
        
        Calcul alpha:
        tau_down_ms = config (ex: 0.5ms)
        freq_ratio = freq / 440Hz
        g_down = freq_ratio^(-beta)
        alpha = (1 - exp(-1/(tau*Fs))) * g_down
        
        **Effet:** Hautes fréquences
        décroissent plus vite
      end note
      
      :for (s = 0; s < 64; s++)\n  v += alpha * (target - v)\n  volumeBuffer[s] = v;
    endif
    
    :Mise à jour current_volume;
    note right
      waves[note].current_volume = v
      (dernier sample du buffer)
    end note
    
    :volumeBuffer[64] samples\nEnveloppe [0, 1]|
  }
  
  partition "3. APPLICATION VOLUME" #PROCESS_COLOR {
    :Multiplication élément par élément;
    note right
      for (s = 0; s < 64; s++)
        waveBuffer[s] *= volumeBuffer[s]
      
      **Résultat:** Signal modulé
      amplitude variable par sample
    end note
    
    :waveBuffer[64] samples\nSignal modulé|
  }
  
  partition "4. MISE À JOUR MAX VOLUME" #PROCESS_COLOR {
    :Détection pic par sample;
    note right
      for (s = 0; s < 64; s++)
        if (volumeBuffer[s] > maxVolumeBuffer[s])
          maxVolumeBuffer[s] = volumeBuffer[s]
      
      **Usage:** Détection pics globaux
      pour normalisation finale
    end note
  }
  
  if (stereo_mode_enabled?) then (oui)
    partition "5A. PANORAMISATION STÉRÉO" #STEREO_COLOR {
      :Récupération gains pré-calculés;
      note right
        **Gains depuis DoubleBuffer:**
        start_L = last_left_gain[note]
        start_R = last_right_gain[note]
        end_L = precomputed_left_gain[note]
        end_R = precomputed_right_gain[note]
        
        **Rampe inter-buffer:**
        Évite clicks lors changement pan
      end note
      
      :Rampe linéaire gains L/R;
      note right
        for (s = 0; s < 64; s++)
          progress = s / 64.0
          gain_L = start_L + progress*(end_L - start_L)
          gain_R = start_R + progress*(end_R - start_R)
          
          temp_L[s] = waveBuffer[s] * gain_L
          temp_R[s] = waveBuffer[s] * gain_R
      end note
      
      :Mémorisation gains finaux;
      note right
        last_left_gain[note] = end_L
        last_right_gain[note] = end_R
        (pour prochain buffer)
      end note
      
      :Accumulation stéréo;
      note right
        for (s = 0; s < 64; s++)
          thread_stereoBuffer_L[s] += temp_L[s]
          thread_stereoBuffer_R[s] += temp_R[s]
      end note
    }
  else (non)
    partition "5B. MODE MONO" #PROCESS_COLOR {
      :Duplication L/R (centre);
      note right
        for (s = 0; s < 64; s++)
          thread_stereoBuffer_L[s] += waveBuffer[s]
          thread_stereoBuffer_R[s] += waveBuffer[s]
        
        **Effet:** Pan centre (0.0)
        Gains L=R=0.707 (constant power)
      end note
    }
  endif
  
  partition "6. SOMMATIONS FINALES" #OUTPUT_COLOR {
    :Somme mono (pour normalisation);
    note right
      for (s = 0; s < 64; s++)
        thread_additiveBuffer[s] += waveBuffer[s]
    end note
    
    :Pondération intelligente volume;
    note right
      **Volume weighting:**
      exp = volume_weighting_exponent (ex: 0.1)
      
      for (s = 0; s < 64; s++)
        weighted = pow(volumeBuffer[s], exp)
        thread_sumVolumeBuffer[s] += weighted
      
      **Effet:** exp < 1 → oscillateurs
      forts dominent (supprime bruit fond)
    end note
  }

repeat while (Plus d'oscillateurs\ndans range?) is (oui)
->non;

:Commit phase continuité;
note right
  **Pour chaque note traitée:**
  waves[note].current_idx = 
    precomputed_new_idx[note][255]
  
  **Garantit:** Phase continue
  entre buffers audio successifs
end note

:Signal work_done = 1;

:Retour pthread_cond_wait();
note right
  Worker en attente du
  prochain cycle de synthèse
end note

stop

legend right
  **Légende Couleurs:**
  |= Couleur |= Signification |
  | <back:#E3F2FD>   </back> | Entrée/Preprocessing |
  | <back:#FFE0B2>   </back> | Traitement Signal |
  | <back:#F8BBD0>   </back> | Stéréo |
  | <back:#C8E6C9>   </back> | Sortie/Accumulation |
  
  **Optimisations Clés:**
  - Pré-computation indices/samples (lock-free)
  - Buffers locaux (pas de contention)
  - NEON SIMD (ARM64 vectorisation)
  - Rampes anti-click (pan, enveloppe)
  - Pondération intelligente (suppression bruit)
  
  **Temps Typique par Oscillateur:**
  - Génération: ~1.5µs
  - Enveloppe: ~2µs
  - Stéréo: ~2.5µs
  - Sommations: ~1.5µs
  **Total: ~7.5µs × 24 notes = ~0.18ms par worker**
endlegend

@enduml
