diff --git a/src/core/config.h b/src/core/config.h
index 8207a0d..43a105c 100644
--- a/src/core/config.h
+++ b/src/core/config.h
@@ -156,8 +156,8 @@ typedef enum {
 } synth_mode_t;
 
 // Default synthesis mode (maintains current behavior)
-// #define SYNTH_MODE SYNTH_MODE_STEREO_WHITE_BG
-#define SYNTH_MODE SYNTH_MODE_STEREO_BLACK_BG
+#define SYNTH_MODE SYNTH_MODE_STEREO_WHITE_BG
+// #define SYNTH_MODE SYNTH_MODE_STEREO_BLACK_BG
 // #define SYNTH_MODE SYNTH_MODE_MONO_WHITE_BG
 // #define SYNTH_MODE SYNTH_MODE_MONO_BLACK_BG
 
@@ -194,8 +194,8 @@ typedef enum {
 #define IMU_FILTER_ALPHA_X                                                     \
   (0.25f) /* Exponential smoothing alpha for acc X (0..1) */
 #define IMU_INACTIVITY_TIMEOUT_S                                               \
-  (5) /* Seconds of no activity before dimming                                 \
-       */
+  (30) /* Seconds of no activity before dimming                                \
+        */
 #define AUTO_VOLUME_INACTIVE_LEVEL                                             \
   (0.09f) /* Target volume when inactive (0.0..1.0) */
 #define AUTO_VOLUME_ACTIVE_LEVEL                                               \
@@ -234,6 +234,15 @@ typedef enum {
 // Non-Linear Intensity Mapping
 #define GAMMA_VALUE 4.8f // Gamma value for non-linear intensity correction
 
+// Temporal Image Smoothing Configuration
+#define ENABLE_IMAGE_TEMPORAL_SMOOTHING 1 // Enable temporal smoothing filter
+#define IMAGE_TEMPORAL_SMOOTHING_ALPHA                                         \
+  0.85f // Smoothing factor (0.0-1.0, higher = more smoothing)
+#define IMAGE_NOISE_GATE_THRESHOLD                                             \
+  0.02f // Noise gate threshold (relative to max amplitude)
+#define IMAGE_ADAPTIVE_SMOOTHING                                               \
+  1 // Enable adaptive smoothing based on variation magnitude
+
 // Logging Parameters
 #define LOG_FREQUENCY                                                          \
   (SAMPLING_FREQUENCY /                                                        \
diff --git a/src/synthesis/additive/synth_additive.c b/src/synthesis/additive/synth_additive.c
index 4980b7a..11ee5b0 100755
--- a/src/synthesis/additive/synth_additive.c
+++ b/src/synthesis/additive/synth_additive.c
@@ -101,6 +101,21 @@ static uint32_t log_counter = 0;
 // static volatile int32_t *full_audio_ptr; // Unused variable
 static int32_t imageRef[NUMBER_OF_NOTES] = {0};
 
+/* Temporal Image Smoothing Filter Structures */
+#if ENABLE_IMAGE_TEMPORAL_SMOOTHING
+typedef struct {
+  float previous_values[CIS_MAX_PIXELS_NB];
+  float smoothed_values[CIS_MAX_PIXELS_NB];
+  int initialized;
+  pthread_mutex_t filter_mutex;
+} ImageTemporalFilter;
+
+// Global filter instances for different processing modes
+static ImageTemporalFilter mono_filter = {0};
+static ImageTemporalFilter warm_filter = {0};
+static ImageTemporalFilter cold_filter = {0};
+#endif
+
 /* Variable used to get converted value */
 // ToChange__IO uint16_t uhADCxConvertedValue = 0;
 
@@ -120,6 +135,15 @@ static void synth_process_worker_range(synth_thread_worker_t *worker);
 static void synth_precompute_wave_data(int32_t *imageData);
 void *synth_persistent_worker_thread(void *arg);
 
+// Temporal image smoothing function prototypes
+#if ENABLE_IMAGE_TEMPORAL_SMOOTHING
+static void init_temporal_filter(ImageTemporalFilter *filter);
+static void cleanup_temporal_filter(ImageTemporalFilter *filter);
+static void apply_temporal_smoothing(int32_t *current_data,
+                                     ImageTemporalFilter *filter,
+                                     uint32_t size);
+#endif
+
 /* Private user code ---------------------------------------------------------*/
 
 void sub_int32(const int32_t *a, const int32_t *b, int32_t *result,
@@ -285,6 +309,28 @@ int32_t synth_IfftInit(void) {
 
   fill_int32(65535, (int32_t *)imageRef, NUMBER_OF_NOTES);
 
+#if ENABLE_IMAGE_TEMPORAL_SMOOTHING
+  // Initialize temporal smoothing filters
+  init_temporal_filter(&mono_filter);
+  init_temporal_filter(&warm_filter);
+  init_temporal_filter(&cold_filter);
+  printf("üîß TEMPORAL_SMOOTHING: Filters initialized for mono and stereo modes\n");
+#endif
+
+  return 0;
+}
+  printf("Note number  = %d\n", (int)NUMBER_OF_NOTES);
+
+  fill_int32(65535, (int32_t *)imageRef, NUMBER_OF_NOTES);
+
+#if ENABLE_IMAGE_TEMPORAL_SMOOTHING
+  // Initialize temporal smoothing filters
+  init_temporal_filter(&mono_filter);
+  init_temporal_filter(&warm_filter);
+  init_temporal_filter(&cold_filter);
+  printf("üîß TEMPORAL_SMOOTHING: Filters initialized for mono and stereo modes\n");
+#endif
+
   return 0;
 }
 
@@ -615,6 +661,124 @@ static float calculate_contrast(int32_t *imageData, size_t size) {
   return result;
 }
 
+#if ENABLE_IMAGE_TEMPORAL_SMOOTHING
+/**
+ * @brief Initialize temporal filter structure
+ * @param filter Pointer to the filter structure to initialize
+ * @retval None
+ */
+static void init_temporal_filter(ImageTemporalFilter *filter) {
+  if (filter == NULL)
+    return;
+
+  // Initialize mutex
+  if (pthread_mutex_init(&filter->filter_mutex, NULL) != 0) {
+    printf("ERROR: Failed to initialize temporal filter mutex\n");
+    return;
+  }
+
+  // Initialize arrays to zero
+  memset(filter->previous_values, 0, sizeof(filter->previous_values));
+  memset(filter->smoothed_values, 0, sizeof(filter->smoothed_values));
+  filter->initialized = 0;
+
+  printf("üîß TEMPORAL_FILTER: Initialized with alpha=%.3f, threshold=%.3f\n",
+         IMAGE_TEMPORAL_SMOOTHING_ALPHA, IMAGE_NOISE_GATE_THRESHOLD);
+}
+
+/**
+ * @brief Cleanup temporal filter structure
+ * @param filter Pointer to the filter structure to cleanup
+ * @retval None
+ */
+static void cleanup_temporal_filter(ImageTemporalFilter *filter) {
+  if (filter == NULL)
+    return;
+
+  pthread_mutex_destroy(&filter->filter_mutex);
+  filter->initialized = 0;
+}
+
+/**
+ * @brief Apply temporal smoothing to image data to reduce sensor noise
+ * artifacts
+ * @param current_data Input/output buffer containing current frame data
+ * @param filter Temporal filter state structure
+ * @param size Number of pixels to process
+ * @retval None
+ */
+static void apply_temporal_smoothing(int32_t *current_data,
+                                     ImageTemporalFilter *filter,
+                                     uint32_t size) {
+  if (current_data == NULL || filter == NULL || size == 0) {
+    return;
+  }
+
+  pthread_mutex_lock(&filter->filter_mutex);
+
+  const float alpha = IMAGE_TEMPORAL_SMOOTHING_ALPHA;
+  const float noise_threshold =
+      IMAGE_NOISE_GATE_THRESHOLD * VOLUME_AMP_RESOLUTION;
+
+  // Statistics for diagnostics
+  static uint32_t call_counter = 0;
+  uint32_t smoothed_pixels = 0;
+  uint32_t significant_changes = 0;
+
+  for (uint32_t i = 0; i < size; i++) {
+    float current = (float)current_data[i];
+
+    if (!filter->initialized) {
+      // First frame: initialize with current values
+      filter->smoothed_values[i] = current;
+      filter->previous_values[i] = current;
+    } else {
+      // Calculate absolute difference from previous frame
+      float diff = fabsf(current - filter->previous_values[i]);
+
+#if IMAGE_ADAPTIVE_SMOOTHING
+      if (diff < noise_threshold) {
+        // Small variation: apply strong smoothing (likely noise)
+        filter->smoothed_values[i] =
+            alpha * filter->smoothed_values[i] + (1.0f - alpha) * current;
+        smoothed_pixels++;
+      } else {
+        // Significant variation: apply reduced smoothing to preserve
+        // responsiveness
+        float adaptive_alpha = alpha * 0.6f; // Reduce smoothing strength
+        filter->smoothed_values[i] =
+            adaptive_alpha * filter->smoothed_values[i] +
+            (1.0f - adaptive_alpha) * current;
+        significant_changes++;
+      }
+#else
+      // Fixed smoothing without adaptation
+      filter->smoothed_values[i] =
+          alpha * filter->smoothed_values[i] + (1.0f - alpha) * current;
+      smoothed_pixels++;
+#endif
+    }
+
+    // Update previous value and output
+    filter->previous_values[i] = current;
+    current_data[i] = (int32_t)filter->smoothed_values[i];
+  }
+
+  filter->initialized = 1;
+
+  // Diagnostic logging (limited frequency)
+  if (call_counter % (LOG_FREQUENCY * 5) == 0) { // Every 5 seconds
+    float smoothing_ratio = (float)smoothed_pixels / size * 100.0f;
+    float change_ratio = (float)significant_changes / size * 100.0f;
+    printf("üîß TEMPORAL_SMOOTH: %.1f%% smoothed, %.1f%% significant changes\n",
+           smoothing_ratio, change_ratio);
+  }
+  call_counter++;
+
+  pthread_mutex_unlock(&filter->filter_mutex);
+}
+#endif // ENABLE_IMAGE_TEMPORAL_SMOOTHING
+
 /**
  * @brief  Structure pour le pool de threads persistants optimis√©
  */
diff --git a/test_color_inversion.c b/test_color_inversion.c
deleted file mode 100644
index b92ee1f..0000000
--- a/test_color_inversion.c
+++ /dev/null
@@ -1,222 +0,0 @@
-/*
- * Test program to verify red/blue color inversion fix
- * This program tests the extractWarmChannel and extractColdChannel functions
- * to ensure that red pixels activate the warm channel and blue pixels activate
- * the cold channel
- */
-
-#include <math.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <string.h>
-
-// Include necessary definitions from config.h
-#define SYNTH_MODE_STEREO_WHITE_BG 2
-#define SYNTH_MODE SYNTH_MODE_STEREO_WHITE_BG
-#define IS_WHITE_BACKGROUND() ((SYNTH_MODE == 0) || (SYNTH_MODE == 2))
-#define VOLUME_AMP_RESOLUTION (65535)
-#define PERCEPTUAL_WEIGHT_R (0.21f)
-#define PERCEPTUAL_WEIGHT_G (0.72f)
-#define PERCEPTUAL_WEIGHT_B (0.07f)
-#define OPPONENT_ALPHA (1.0f)
-#define OPPONENT_BETA (0.5f)
-#define CHROMATIC_THRESHOLD (0.1f)
-#define ACHROMATIC_SPLIT (0.5f)
-
-// Function prototypes (copied from synth_additive.c)
-uint32_t extractWarmChannel(uint8_t *buffer_R, uint8_t *buffer_G,
-                            uint8_t *buffer_B, int32_t *warm_output,
-                            uint32_t size);
-uint32_t extractColdChannel(uint8_t *buffer_R, uint8_t *buffer_G,
-                            uint8_t *buffer_B, int32_t *cold_output,
-                            uint32_t size);
-
-// Simplified implementations for testing
-uint32_t extractWarmChannel(uint8_t *buffer_R, uint8_t *buffer_G,
-                            uint8_t *buffer_B, int32_t *warm_output,
-                            uint32_t size) {
-  for (uint32_t i = 0; i < size; i++) {
-    // Step 1: Convert RGB to normalized [0..1] values
-    float r_norm = (float)buffer_R[i] / 255.0f;
-    float g_norm = (float)buffer_G[i] / 255.0f;
-    float b_norm = (float)buffer_B[i] / 255.0f;
-
-    // Step 2: Calculate perceptual luminance Y
-    float luminance_Y = PERCEPTUAL_WEIGHT_R * r_norm +
-                        PERCEPTUAL_WEIGHT_G * g_norm +
-                        PERCEPTUAL_WEIGHT_B * b_norm;
-
-    // Step 3: Calculate opponent axes (CORRECTED)
-    float O_rb =
-        b_norm -
-        r_norm; // Blue-Red opponent axis (corrected for intuitive behavior)
-    float O_gm =
-        (2.0f * g_norm - r_norm - b_norm) / 2.0f; // Green-Magenta opponent axis
-
-    // Step 4: Calculate warm/cold scores
-    float S_warm = fmaxf(0.0f, OPPONENT_ALPHA * O_rb + OPPONENT_BETA * O_gm);
-    float S_cold =
-        fmaxf(0.0f, OPPONENT_ALPHA * (-O_rb) + OPPONENT_BETA * (-O_gm));
-
-    // Step 5: Determine if color is chromatic or achromatic
-    float total_chroma = S_warm + S_cold;
-    float warm_proportion;
-
-    if (total_chroma > CHROMATIC_THRESHOLD) {
-      // Chromatic color: calculate proportion based on warm/cold scores
-      warm_proportion = S_warm / total_chroma;
-    } else {
-      // Achromatic color (gray/white/black): use 50/50 split
-      warm_proportion = ACHROMATIC_SPLIT;
-    }
-
-    // Step 6: Weight by luminosity and convert to 16-bit
-    float warm_energy;
-    if (total_chroma > CHROMATIC_THRESHOLD) {
-      // Chromatic color: use proportional energy
-      warm_energy = luminance_Y * warm_proportion;
-    } else {
-      // Achromatic color: use full luminance energy (like mono mode)
-      warm_energy = luminance_Y;
-    }
-    int32_t final_value = (int32_t)(warm_energy * VOLUME_AMP_RESOLUTION);
-
-    // Apply color inversion based on SYNTH_MODE (unified system)
-    if (IS_WHITE_BACKGROUND()) {
-      // White background mode: dark pixels = more energy
-      final_value = VOLUME_AMP_RESOLUTION - final_value;
-      if (final_value < 0)
-        final_value = 0;
-      if (final_value > VOLUME_AMP_RESOLUTION)
-        final_value = VOLUME_AMP_RESOLUTION;
-    }
-
-    warm_output[i] = final_value;
-  }
-  return 0;
-}
-
-uint32_t extractColdChannel(uint8_t *buffer_R, uint8_t *buffer_G,
-                            uint8_t *buffer_B, int32_t *cold_output,
-                            uint32_t size) {
-  for (uint32_t i = 0; i < size; i++) {
-    // Step 1: Convert RGB to normalized [0..1] values
-    float r_norm = (float)buffer_R[i] / 255.0f;
-    float g_norm = (float)buffer_G[i] / 255.0f;
-    float b_norm = (float)buffer_B[i] / 255.0f;
-
-    // Step 2: Calculate perceptual luminance Y
-    float luminance_Y = PERCEPTUAL_WEIGHT_R * r_norm +
-                        PERCEPTUAL_WEIGHT_G * g_norm +
-                        PERCEPTUAL_WEIGHT_B * b_norm;
-
-    // Step 3: Calculate opponent axes (CORRECTED)
-    float O_rb =
-        b_norm -
-        r_norm; // Blue-Red opponent axis (corrected for intuitive behavior)
-    float O_gm =
-        (2.0f * g_norm - r_norm - b_norm) / 2.0f; // Green-Magenta opponent axis
-
-    // Step 4: Calculate warm/cold scores
-    float S_warm = fmaxf(0.0f, OPPONENT_ALPHA * O_rb + OPPONENT_BETA * O_gm);
-    float S_cold =
-        fmaxf(0.0f, OPPONENT_ALPHA * (-O_rb) + OPPONENT_BETA * (-O_gm));
-
-    // Step 5: Determine if color is chromatic or achromatic
-    float total_chroma = S_warm + S_cold;
-    float cold_proportion;
-
-    if (total_chroma > CHROMATIC_THRESHOLD) {
-      // Chromatic color: calculate proportion based on warm/cold scores
-      cold_proportion = S_cold / total_chroma;
-    } else {
-      // Achromatic color (gray/white/black): use 50/50 split
-      cold_proportion = 1.0f - ACHROMATIC_SPLIT; // Complement of warm split
-    }
-
-    // Step 6: Weight by luminosity and convert to 16-bit
-    float cold_energy;
-    if (total_chroma > CHROMATIC_THRESHOLD) {
-      // Chromatic color: use proportional energy
-      cold_energy = luminance_Y * cold_proportion;
-    } else {
-      // Achromatic color: use full luminance energy (like mono mode)
-      cold_energy = luminance_Y;
-    }
-    int32_t final_value = (int32_t)(cold_energy * VOLUME_AMP_RESOLUTION);
-
-    // Apply color inversion based on SYNTH_MODE (unified system)
-    if (IS_WHITE_BACKGROUND()) {
-      // White background mode: dark pixels = more energy
-      final_value = VOLUME_AMP_RESOLUTION - final_value;
-      if (final_value < 0)
-        final_value = 0;
-      if (final_value > VOLUME_AMP_RESOLUTION)
-        final_value = VOLUME_AMP_RESOLUTION;
-    }
-
-    cold_output[i] = final_value;
-  }
-  return 0;
-}
-
-int main() {
-  printf("=== Test de correction de l'inversion rouge-bleu ===\n\n");
-
-  // Test cases: pure colors on white background
-  uint8_t test_colors[][3] = {
-      {255, 0, 0},     // Pure red
-      {0, 0, 255},     // Pure blue
-      {0, 255, 0},     // Pure green
-      {255, 255, 255}, // White
-      {0, 0, 0},       // Black
-      {128, 128, 128}, // Gray
-      {255, 128, 0},   // Orange (warm)
-      {0, 128, 255}    // Cyan (cold)
-  };
-
-  const char *color_names[] = {"Rouge pur", "Bleu pur", "Vert pur", "Blanc",
-                               "Noir",      "Gris",     "Orange",   "Cyan"};
-
-  int num_tests = sizeof(test_colors) / sizeof(test_colors[0]);
-
-  for (int i = 0; i < num_tests; i++) {
-    uint8_t r = test_colors[i][0];
-    uint8_t g = test_colors[i][1];
-    uint8_t b = test_colors[i][2];
-
-    int32_t warm_output, cold_output;
-
-    extractWarmChannel(&r, &g, &b, &warm_output, 1);
-    extractColdChannel(&r, &g, &b, &cold_output, 1);
-
-    printf("%-12s RGB(%3d,%3d,%3d) -> Warm: %5d, Cold: %5d", color_names[i], r,
-           g, b, warm_output, cold_output);
-
-    // Analyze results
-    if (i == 0) { // Pure red
-      if (warm_output > cold_output) {
-        printf(" ‚úÖ Rouge active plus le canal warm");
-      } else {
-        printf(" ‚ùå Rouge devrait activer plus le canal warm");
-      }
-    } else if (i == 1) { // Pure blue
-      if (cold_output > warm_output) {
-        printf(" ‚úÖ Bleu active plus le canal cold");
-      } else {
-        printf(" ‚ùå Bleu devrait activer plus le canal cold");
-      }
-    }
-
-    printf("\n");
-  }
-
-  printf("\n=== R√©sum√© ===\n");
-  printf("Mode: SYNTH_MODE_STEREO_WHITE_BG\n");
-  printf("Fond blanc: les pixels sombres g√©n√®rent plus d'√©nergie\n");
-  printf("Axe opponent corrig√©: O_rb = b_norm - r_norm\n");
-  printf("Canal warm (gauche): devrait r√©agir plus au rouge\n");
-  printf("Canal cold (droit): devrait r√©agir plus au bleu\n");
-
-  return 0;
-}
diff --git a/test_stereo_logic.c b/test_stereo_logic.c
deleted file mode 100644
index 06489cd..0000000
--- a/test_stereo_logic.c
+++ /dev/null
@@ -1,90 +0,0 @@
-/* test_stereo_logic.c - Test pour comprendre la logique st√©r√©o */
-
-#include "config.h"
-#include <stdint.h>
-#include <stdio.h>
-
-// Simuler les fonctions d'extraction
-uint32_t extractRedChannel_test(uint8_t red_value) {
-  if (IS_WHITE_BACKGROUND()) {
-    // White background mode: invert colors (dark pixels = more sound)
-    return (uint32_t)(((255UL - red_value) * 65535UL) / 255UL);
-  } else {
-    // Black background mode: direct conversion (light pixels = more sound)
-    return (uint32_t)((red_value * 65535UL) / 255UL);
-  }
-}
-
-uint32_t extractBlueChannel_test(uint8_t blue_value) {
-  if (IS_WHITE_BACKGROUND()) {
-    // White background mode: invert colors (dark pixels = more sound)
-    return (uint32_t)(((255UL - blue_value) * 65535UL) / 255UL);
-  } else {
-    // Black background mode: direct conversion (light pixels = more sound)
-    return (uint32_t)((blue_value * 65535UL) / 255UL);
-  }
-}
-
-uint32_t greyScale_test(uint8_t r, uint8_t g, uint8_t b) {
-  uint32_t weighted = (r * 299 + g * 587 + b * 114);
-  // Normalisation en 16 bits (0 - 65535)
-  return (uint32_t)((weighted * 65535UL) / 255000UL);
-}
-
-int main() {
-  printf("=== Test de la logique St√©r√©o vs Mono ===\n\n");
-
-  // Test avec diff√©rents sc√©narios
-  printf("Configuration actuelle: SYNTH_MODE = %d\n", SYNTH_MODE);
-  printf("IS_STEREO_MODE(): %s\n", IS_STEREO_MODE() ? "true" : "false");
-  printf("IS_WHITE_BACKGROUND(): %s\n",
-         IS_WHITE_BACKGROUND() ? "true" : "false");
-  printf("\n");
-
-  // Sc√©nario 1: Pixels rouges sur fond blanc
-  printf("=== Sc√©nario 1: Pixels rouges (255,0,0) sur fond blanc ===\n");
-  uint8_t red_pixel_r = 255, red_pixel_g = 0, red_pixel_b = 0;
-  uint32_t mono_result = greyScale_test(red_pixel_r, red_pixel_g, red_pixel_b);
-  uint32_t stereo_left = extractRedChannel_test(red_pixel_r);
-  uint32_t stereo_right = extractBlueChannel_test(red_pixel_b);
-
-  printf("Mono (greyScale): %u\n", mono_result);
-  printf("St√©r√©o Left (rouge): %u\n", stereo_left);
-  printf("St√©r√©o Right (bleu): %u\n", stereo_right);
-  printf("\n");
-
-  // Sc√©nario 2: Pixels noirs sur fond blanc
-  printf("=== Sc√©nario 2: Pixels noirs (0,0,0) sur fond blanc ===\n");
-  uint8_t black_pixel_r = 0, black_pixel_g = 0, black_pixel_b = 0;
-  mono_result = greyScale_test(black_pixel_r, black_pixel_g, black_pixel_b);
-  stereo_left = extractRedChannel_test(black_pixel_r);
-  stereo_right = extractBlueChannel_test(black_pixel_b);
-
-  printf("Mono (greyScale): %u\n", mono_result);
-  printf("St√©r√©o Left (rouge): %u\n", stereo_left);
-  printf("St√©r√©o Right (bleu): %u\n", stereo_right);
-  printf("\n");
-
-  // Sc√©nario 3: Fond blanc
-  printf("=== Sc√©nario 3: Fond blanc (255,255,255) ===\n");
-  uint8_t white_r = 255, white_g = 255, white_b = 255;
-  mono_result = greyScale_test(white_r, white_g, white_b);
-  stereo_left = extractRedChannel_test(white_r);
-  stereo_right = extractBlueChannel_test(white_b);
-
-  printf("Mono (greyScale): %u\n", mono_result);
-  printf("St√©r√©o Left (rouge): %u\n", stereo_left);
-  printf("St√©r√©o Right (bleu): %u\n", stereo_right);
-  printf("\n");
-
-  printf("=== Analyse ===\n");
-  printf("PROBL√àME IDENTIFI√â:\n");
-  printf("- En mode mono: pixels noirs (0,0,0) donnent maximum de son\n");
-  printf("- En mode st√©r√©o: pixels rouges (255,0,0) ne donnent du son QUE dans "
-         "le canal gauche\n");
-  printf("- Pour avoir du son st√©r√©o √©quivalent au mono, il faudrait des "
-         "pixels violets (255,0,255)\n");
-  printf("  ou traiter diff√©remment l'extraction des canaux.\n");
-
-  return 0;
-}
diff --git a/test_synthesis_modes.c b/test_synthesis_modes.c
deleted file mode 100644
index 14ef72e..0000000
--- a/test_synthesis_modes.c
+++ /dev/null
@@ -1,65 +0,0 @@
-/* test_synthesis_modes.c - Test program to verify synthesis mode configuration
- */
-
-#include "config.h"
-#include <stdio.h>
-
-int main() {
-  printf("=== Sp3ctra Synthesis Mode Configuration Test ===\n\n");
-
-  // Display current configuration
-  printf("Current SYNTH_MODE: %d\n", SYNTH_MODE);
-
-  // Test mode detection macros
-  printf("IS_STEREO_MODE(): %s\n", IS_STEREO_MODE() ? "true" : "false");
-  printf("IS_WHITE_BACKGROUND(): %s\n",
-         IS_WHITE_BACKGROUND() ? "true" : "false");
-  printf("COLOR_INVERTED (legacy): %s\n", COLOR_INVERTED ? "true" : "false");
-
-  // Display mode interpretation
-  printf("\nMode interpretation:\n");
-  switch (SYNTH_MODE) {
-  case SYNTH_MODE_MONO_WHITE_BG:
-    printf("- Mono synthesis with white background\n");
-    printf("- Dark pixels = more audio energy\n");
-    break;
-  case SYNTH_MODE_MONO_BLACK_BG:
-    printf("- Mono synthesis with black background\n");
-    printf("- Light pixels = more audio energy\n");
-    break;
-  case SYNTH_MODE_STEREO_WHITE_BG:
-    printf("- Stereo synthesis with white background\n");
-    printf("- Red channel -> Left audio, Blue channel -> Right audio\n");
-    printf("- Dark pixels = more audio energy\n");
-    break;
-  case SYNTH_MODE_STEREO_BLACK_BG:
-    printf("- Stereo synthesis with black background\n");
-    printf("- Red channel -> Left audio, Blue channel -> Right audio\n");
-    printf("- Light pixels = more audio energy\n");
-    break;
-  default:
-    printf("- Unknown mode!\n");
-    break;
-  }
-
-  printf("\nAudio processing function selection:\n");
-  if (IS_STEREO_MODE()) {
-    printf("- Using synth_AudioProcessStereo()\n");
-    printf("- Independent processing for left and right channels\n");
-  } else {
-    printf("- Using synth_AudioProcess() (mono)\n");
-    printf("- Single channel processing\n");
-  }
-
-  printf("\nColor inversion logic:\n");
-  if (IS_WHITE_BACKGROUND()) {
-    printf("- White background mode: 255 - pixel_value\n");
-    printf("- Dark areas produce more sound\n");
-  } else {
-    printf("- Black background mode: pixel_value (no inversion)\n");
-    printf("- Light areas produce more sound\n");
-  }
-
-  printf("\n=== Test completed successfully! ===\n");
-  return 0;
-}
